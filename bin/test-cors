#!/usr/bin/env python3
"""
test-cors - CORS Configuration Testing Tool

Tests CORS headers on API endpoints by sending preflight OPTIONS requests
and actual requests with different origins.

Usage:
  test-cors <api-endpoint> <origin> [method]
  test-cors --batch <api-endpoint> <origin1> <origin2> ...
  test-cors --full
  test-cors --help

Examples:
  # Test single origin
  test-cors https://eu.onetimesecret.com/api/v2/secret/conceal https://onetimesecret.com

  # Test with specific HTTP method
  test-cors https://eu.onetimesecret.com/api/v2/secret/conceal https://onetimesecret.com POST

  # Batch test multiple origins
  test-cors --batch https://eu.onetimesecret.com/api/v2/secret/conceal \\
    https://onetimesecret.com \\
    https://www.onetimesecret.com \\
    http://localhost:4321

  # Run full test suite (all regions, all origins)
  test-cors --full
"""

import argparse
import sys
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional, Tuple
from urllib.parse import urlparse

try:
    import requests
except ImportError:
    print("Error: requests library not found. Please install it:")
    print("  pip install requests")
    sys.exit(1)


class TestResult(Enum):
    """Test result status"""
    PASSED = "passed"
    FAILED = "failed"
    PARTIAL = "partial"
    ERROR = "error"


@dataclass
class CORSTestResult:
    """Result of a CORS test"""
    endpoint: str
    origin: str
    method: str
    status: TestResult
    status_code: Optional[int]
    cors_headers: Dict[str, str]
    missing_headers: List[str]
    error_message: Optional[str] = None

    def is_success(self) -> bool:
        """Check if test passed"""
        return self.status == TestResult.PASSED


class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    BOLD = '\033[1m'
    NC = '\033[0m'  # No Color

    @staticmethod
    def disable():
        """Disable colors (for non-TTY output)"""
        Colors.RED = ''
        Colors.GREEN = ''
        Colors.YELLOW = ''
        Colors.BLUE = ''
        Colors.CYAN = ''
        Colors.BOLD = ''
        Colors.NC = ''


class CORSTester:
    """CORS configuration testing tool"""

    # CORS headers to validate
    CORS_HEADERS = [
        'access-control-allow-origin',
        'access-control-allow-methods',
        'access-control-allow-headers',
        'access-control-allow-credentials',
        'access-control-max-age',
    ]

    # Default test configuration
    DEFAULT_REGIONS = [
        'https://eu.onetimesecret.com',
        'https://ca.onetimesecret.com',
        'https://us.onetimesecret.com',
        'https://nz.onetimesecret.com',
    ]

    DEFAULT_ORIGINS = [
        'https://onetimesecret.com',
        'https://www.onetimesecret.com',
        'http://localhost:4321',
    ]

    DEFAULT_ENDPOINT_PATH = '/api/v2/secret/conceal'
    DEFAULT_TIMEOUT = 10

    def __init__(self, timeout: int = DEFAULT_TIMEOUT, verbose: bool = False):
        self.timeout = timeout
        self.verbose = verbose

    def test_cors_preflight(
        self,
        endpoint: str,
        origin: str,
        method: str = 'POST'
    ) -> CORSTestResult:
        """
        Test CORS preflight (OPTIONS) request.

        Args:
            endpoint: Full URL of the API endpoint
            origin: Origin URL to test from
            method: HTTP method to test (default: POST)

        Returns:
            CORSTestResult with test outcome
        """
        self._print_header("CORS Preflight Test")
        self._print_info(f"Endpoint: {Colors.BOLD}{endpoint}{Colors.NC}")
        self._print_info(f"Origin: {Colors.BOLD}{origin}{Colors.NC}")
        self._print_info(f"Method: {Colors.BOLD}{method}{Colors.NC}")

        self._print_subheader("Sending OPTIONS request...")

        headers = {
            'Origin': origin,
            'Access-Control-Request-Method': method,
            'Access-Control-Request-Headers': 'Content-Type',
        }

        try:
            response = requests.options(
                endpoint,
                headers=headers,
                timeout=self.timeout
            )
        except requests.exceptions.RequestException as e:
            self._print_error(f"Failed to connect to endpoint: {e}")
            return CORSTestResult(
                endpoint=endpoint,
                origin=origin,
                method=method,
                status=TestResult.ERROR,
                status_code=None,
                cors_headers={},
                missing_headers=self.CORS_HEADERS,
                error_message=str(e)
            )

        self._print_subheader(f"Response Status: {response.status_code}")

        # Extract CORS headers
        cors_headers = {}
        missing_headers = []

        self._print_subheader("CORS Headers:")

        for header in self.CORS_HEADERS:
            value = response.headers.get(header)
            if value:
                cors_headers[header] = value
                self._print_success(f"{header}: {value}")
            else:
                missing_headers.append(header)
                self._print_error(f"{header}: {Colors.RED}[MISSING]{Colors.NC}")

        # Determine test status
        if not missing_headers:
            status = TestResult.PASSED
            self._print_success(f"\n{Colors.BOLD}CORS is properly configured{Colors.NC}")
        elif not cors_headers:
            status = TestResult.FAILED
            self._print_error(
                f"\n{Colors.BOLD}CORS is NOT configured - no headers found{Colors.NC}"
            )
        else:
            status = TestResult.PARTIAL
            self._print_warning(
                f"\n{Colors.BOLD}Partial CORS configuration - "
                f"some headers missing{Colors.NC}"
            )

        return CORSTestResult(
            endpoint=endpoint,
            origin=origin,
            method=method,
            status=status,
            status_code=response.status_code,
            cors_headers=cors_headers,
            missing_headers=missing_headers
        )

    def test_cors_request(
        self,
        endpoint: str,
        origin: str,
        method: str = 'POST'
    ) -> CORSTestResult:
        """
        Test actual CORS request.

        Args:
            endpoint: Full URL of the API endpoint
            origin: Origin URL to test from
            method: HTTP method to test (default: POST)

        Returns:
            CORSTestResult with test outcome
        """
        self._print_header("CORS Actual Request Test")
        self._print_info(f"Endpoint: {Colors.BOLD}{endpoint}{Colors.NC}")
        self._print_info(f"Origin: {Colors.BOLD}{origin}{Colors.NC}")
        self._print_info(f"Method: {Colors.BOLD}{method}{Colors.NC}")

        self._print_subheader(f"Sending {method} request...")

        headers = {
            'Origin': origin,
            'Content-Type': 'application/json',
        }

        # Test payload for POST requests
        payload = {
            'secret': {
                'secret': 'test',
                'ttl': 604800,
                'passphrase': None
            }
        }

        try:
            if method == 'POST':
                response = requests.post(
                    endpoint,
                    headers=headers,
                    json=payload,
                    timeout=self.timeout
                )
            else:
                response = requests.request(
                    method,
                    endpoint,
                    headers=headers,
                    timeout=self.timeout
                )
        except requests.exceptions.RequestException as e:
            self._print_error(f"Failed to connect to endpoint: {e}")
            return CORSTestResult(
                endpoint=endpoint,
                origin=origin,
                method=method,
                status=TestResult.ERROR,
                status_code=None,
                cors_headers={},
                missing_headers=['access-control-allow-origin'],
                error_message=str(e)
            )

        self._print_subheader(f"Response Status: {response.status_code}")

        # Check for CORS header in response
        allow_origin = response.headers.get('access-control-allow-origin')

        if allow_origin:
            self._print_success(f"CORS header present: {allow_origin}")
            status = TestResult.PASSED
            cors_headers = {'access-control-allow-origin': allow_origin}
            missing_headers = []
        else:
            self._print_error("CORS header missing in response")
            status = TestResult.FAILED
            cors_headers = {}
            missing_headers = ['access-control-allow-origin']

        return CORSTestResult(
            endpoint=endpoint,
            origin=origin,
            method=method,
            status=status,
            status_code=response.status_code,
            cors_headers=cors_headers,
            missing_headers=missing_headers
        )

    def test_single_origin(
        self,
        endpoint: str,
        origin: str,
        method: str = 'POST',
        skip_request_on_preflight_failure: bool = True
    ) -> Tuple[CORSTestResult, Optional[CORSTestResult]]:
        """
        Test a single origin against an endpoint.

        Args:
            endpoint: Full URL of the API endpoint
            origin: Origin URL to test from
            method: HTTP method to test
            skip_request_on_preflight_failure: If True, skip actual request
                if preflight fails (default: True)

        Returns:
            Tuple of (preflight_result, request_result)
            request_result may be None if skipped
        """
        # Always run preflight test
        preflight_result = self.test_cors_preflight(endpoint, origin, method)

        # Only run actual request if preflight passed or if not skipping
        request_result = None
        if preflight_result.is_success() or not skip_request_on_preflight_failure:
            print()  # Add spacing
            request_result = self.test_cors_request(endpoint, origin, method)
        elif skip_request_on_preflight_failure:
            self._print_warning(
                "\n⚠ Skipping actual request test because preflight failed"
            )

        return preflight_result, request_result

    def test_batch_origins(
        self,
        endpoint: str,
        origins: List[str],
        method: str = 'POST'
    ) -> List[Tuple[CORSTestResult, Optional[CORSTestResult]]]:
        """
        Test multiple origins against a single endpoint.

        Args:
            endpoint: Full URL of the API endpoint
            origins: List of origin URLs to test
            method: HTTP method to test

        Returns:
            List of (preflight_result, request_result) tuples
        """
        self._print_header("Batch CORS Testing")
        self._print_info(f"Testing {len(origins)} origins against: {endpoint}")

        results = []
        for i, origin in enumerate(origins, 1):
            print()  # Add spacing
            self._print_subheader(f"[{i}/{len(origins)}] Testing origin: {origin}")
            print()

            result = self.test_single_origin(endpoint, origin, method)
            results.append(result)

        # Summary
        self._print_batch_summary(results)

        return results

    def test_full_suite(self) -> Dict[str, List[Tuple[CORSTestResult, Optional[CORSTestResult]]]]:
        """
        Run full test suite across all regions and origins.

        Returns:
            Dictionary mapping regions to test results
        """
        self._print_header("Full CORS Test Suite")

        total_tests = len(self.DEFAULT_REGIONS) * len(self.DEFAULT_ORIGINS)
        self._print_info(
            f"Running {total_tests} tests across "
            f"{len(self.DEFAULT_REGIONS)} regions and "
            f"{len(self.DEFAULT_ORIGINS)} origins"
        )

        results = {}
        current = 0

        for region in self.DEFAULT_REGIONS:
            endpoint = f"{region}{self.DEFAULT_ENDPOINT_PATH}"
            region_results = []

            for origin in self.DEFAULT_ORIGINS:
                current += 1
                region_name = urlparse(region).netloc
                origin_name = urlparse(origin).netloc or origin

                print()
                self._print_subheader(
                    f"[{current}/{total_tests}] Testing: "
                    f"{region_name} with origin: {origin_name}"
                )

                # Only run preflight for full suite to save time
                preflight_result = self.test_cors_preflight(endpoint, origin)
                region_results.append((preflight_result, None))

            results[region] = region_results

        # Final summary
        self._print_full_suite_summary(results)

        return results

    def _print_batch_summary(
        self,
        results: List[Tuple[CORSTestResult, Optional[CORSTestResult]]]
    ):
        """Print summary for batch tests"""
        passed = sum(1 for r, _ in results if r.is_success())
        failed = len(results) - passed

        self._print_header("Batch Test Summary")
        print(f"Total tests: {Colors.BOLD}{len(results)}{Colors.NC}")
        print(f"Passed: {Colors.GREEN}{passed}{Colors.NC}")
        print(f"Failed: {Colors.RED}{failed}{Colors.NC}")

        if failed == 0:
            self._print_success(f"{Colors.BOLD}All tests passed!{Colors.NC}")
        else:
            self._print_error(f"{Colors.BOLD}Some tests failed{Colors.NC}")

    def _print_full_suite_summary(
        self,
        results: Dict[str, List[Tuple[CORSTestResult, Optional[CORSTestResult]]]]
    ):
        """Print summary for full test suite"""
        total = sum(len(r) for r in results.values())
        passed = sum(
            1 for region_results in results.values()
            for r, _ in region_results
            if r.is_success()
        )
        failed = total - passed

        self._print_header("Full Test Suite Summary")
        print(f"Total tests: {Colors.BOLD}{total}{Colors.NC}")
        print(f"Passed: {Colors.GREEN}{passed}{Colors.NC}")
        print(f"Failed: {Colors.RED}{failed}{Colors.NC}")

        if failed == 0:
            self._print_success(f"{Colors.BOLD}All tests passed!{Colors.NC}")
        else:
            self._print_error(f"{Colors.BOLD}{failed} test(s) failed{Colors.NC}")

    def _print_header(self, text: str):
        """Print a header line"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}{'━' * 60}{Colors.NC}")
        print(f"{Colors.BOLD}{Colors.CYAN}{text}{Colors.NC}")
        print(f"{Colors.BOLD}{Colors.BLUE}{'━' * 60}{Colors.NC}")

    def _print_subheader(self, text: str):
        """Print a subheader"""
        print(f"\n{Colors.BOLD}{text}{Colors.NC}")

    def _print_success(self, text: str):
        """Print success message"""
        print(f"{Colors.GREEN}✓{Colors.NC} {text}")

    def _print_error(self, text: str):
        """Print error message"""
        print(f"{Colors.RED}✗{Colors.NC} {text}")

    def _print_warning(self, text: str):
        """Print warning message"""
        print(f"{Colors.YELLOW}⚠{Colors.NC} {text}")

    def _print_info(self, text: str):
        """Print info message"""
        print(f"{Colors.BLUE}ℹ{Colors.NC} {text}")


def create_parser() -> argparse.ArgumentParser:
    """Create argument parser"""
    parser = argparse.ArgumentParser(
        description='CORS Configuration Testing Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Test single origin
  test-cors https://eu.onetimesecret.com/api/v2/secret/conceal https://onetimesecret.com

  # Test with specific HTTP method
  test-cors https://eu.onetimesecret.com/api/v2/secret/conceal https://onetimesecret.com POST

  # Batch test multiple origins
  test-cors --batch https://eu.onetimesecret.com/api/v2/secret/conceal \\
    https://onetimesecret.com \\
    https://www.onetimesecret.com \\
    http://localhost:4321

  # Run full test suite
  test-cors --full

Output:
  ✓ CORS headers present and valid
  ✗ CORS headers missing or invalid
  ⚠ Partial CORS configuration
        """
    )

    parser.add_argument(
        'endpoint',
        nargs='?',
        help='Full URL of the API endpoint to test'
    )
    parser.add_argument(
        'origin',
        nargs='?',
        help='Origin URL to test from (e.g., https://example.com)'
    )
    parser.add_argument(
        'method',
        nargs='?',
        default='POST',
        help='HTTP method to test (default: POST)'
    )

    parser.add_argument(
        '--batch',
        action='store_true',
        help='Test multiple origins against one endpoint'
    )
    parser.add_argument(
        '--full',
        action='store_true',
        help='Run complete test suite (all regions, all origins)'
    )
    parser.add_argument(
        '--origins',
        nargs='+',
        help='List of origins for batch testing'
    )
    parser.add_argument(
        '--timeout',
        type=int,
        default=CORSTester.DEFAULT_TIMEOUT,
        help=f'Request timeout in seconds (default: {CORSTester.DEFAULT_TIMEOUT})'
    )
    parser.add_argument(
        '--no-color',
        action='store_true',
        help='Disable colored output'
    )
    parser.add_argument(
        '--verbose',
        '-v',
        action='store_true',
        help='Enable verbose output'
    )

    return parser


def main():
    """Main entry point"""
    parser = create_parser()
    args = parser.parse_args()

    # Disable colors if requested or if not a TTY
    if args.no_color or not sys.stdout.isatty():
        Colors.disable()

    # Create tester instance
    tester = CORSTester(timeout=args.timeout, verbose=args.verbose)

    # Handle different modes
    if args.full:
        # Full test suite
        results = tester.test_full_suite()
        # Exit with error if any tests failed
        all_passed = all(
            r.is_success()
            for region_results in results.values()
            for r, _ in region_results
        )
        sys.exit(0 if all_passed else 1)

    elif args.batch:
        # Batch testing mode
        if not args.endpoint:
            parser.error("--batch requires an endpoint URL")
        if not args.origins:
            parser.error("--batch requires --origins with at least one origin")

        results = tester.test_batch_origins(
            args.endpoint,
            args.origins,
            args.method
        )
        # Exit with error if any tests failed
        all_passed = all(r.is_success() for r, _ in results)
        sys.exit(0 if all_passed else 1)

    else:
        # Single origin testing
        if not args.endpoint or not args.origin:
            parser.error("endpoint and origin are required")

        preflight_result, request_result = tester.test_single_origin(
            args.endpoint,
            args.origin,
            args.method
        )

        # Exit with error if preflight failed or request failed (if it ran)
        if not preflight_result.is_success():
            sys.exit(1)
        if request_result and not request_result.is_success():
            sys.exit(1)
        sys.exit(0)


if __name__ == '__main__':
    main()
